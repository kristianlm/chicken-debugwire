;; extracted from manual, then patched up manually. if you want to add
;; an opcode, please make take into account various transformations
;; the operands need. for example, flash addresses (see rjmp) need to
;; be halfed as the PC points to flash word address (not byte). You'll
;; find this in the AVR Instruction Set Manual and

(define encoding-specs
  `((define-instruction adc    "Add with Carry" (d r) "0001 11rd dddd rrrr")
    ;;(define-instruction add    "Add without Carry" (d r) "0000 11rd dddd rrrr")
    ;;(define-instruction adiw   "Add Immediate to Word" (d K) "1001 0110 KKdd KKKK")
    (define-instruction and    "Logical AND" (d r) "0010 00rd dddd rrrr")
    ;;(define-instruction andi   "Logical AND with Immediate" (d K) "0111 KKKK dddd KKKK")
    (define-instruction asr    "Arithmetic Shift Right" (d)   "1001 010d dddd 0101")
    (define-instruction bclr   "Bit Clear in SREG" (s)   "1001 0100 1sss 1000")
    (define-instruction bld    "Bit Load from the T Bit in SREG to a Bit in Register" (b d) "1111 100d dddd 0bbb")
    (define-instruction brbc   "Branch if Bit in SREG is Cleared" (k s) "1111 01kk kkkk ksss")
    (define-instruction brbs   "Branch if Bit in SREG is Set" (k s) "1111 00kk kkkk ksss")
    (define-instruction brcc   "Branch if Carry Cleared" (k)   "1111 01kk kkkk k000")
    (define-instruction brcs   "Branch if Carry Set" (k)   "1111 00kk kkkk k000")
    ;;(define-instruction break  "Break" ()    "1001 0101 1001 1000")
    ;;(define-instruction breq   "Branch if Equal" (k)   "1111 00kk kkkk k001")
    (define-instruction brge   "Branch if Greater or Equal (Signed)" (k)   "1111 01kk kkkk k100")
    (define-instruction brhc   "Branch if Half Carry Flag is Cleared" (k)   "1111 01kk kkkk k101")
    (define-instruction brhs   "Branch if Half Carry Flag is Set" (k)   "1111 00kk kkkk k101")
    (define-instruction brid   "Branch if Global Interrupt is Disabled" (k)   "1111 01kk kkkk k111")
    (define-instruction brie   "Branch if Global Interrupt is Enabled" (k)   "1111 00kk kkkk k111")
    (define-instruction brlo   "Branch if Lower (Unsigned)" (k)   "1111 00kk kkkk k000")
    (define-instruction brlt   "Branch if Less Than (Signed)" (k)   "1111 00kk kkkk k100")
    (define-instruction brmi   "Branch if Minus" (k)   "1111 00kk kkkk k010")
    ;;(define-instruction brne   "Branch if Not Equal" (k)   "1111 01kk kkkk k001")
    (define-instruction brpl   "Branch if Plus" (k)   "1111 01kk kkkk k010")
    (define-instruction brsh   "Branch if Same or Higher (Unsigned)" (k)   "1111 01kk kkkk k000")
    (define-instruction brtc   "Branch if the T Bit is Cleared" (k)   "1111 01kk kkkk k110")
    (define-instruction brts   "Branch if the T Bit is Set" (k)   "1111 00kk kkkk k110")
    (define-instruction brvc   "Branch if Overflow Cleared" (k)   "1111 01kk kkkk k011")
    (define-instruction brvs   "Branch if Overflow Set" (k)   "1111 00kk kkkk k011")
    (define-instruction bset   "Bit Set in SREG" (s)   "1001 0100 0sss 1000")
    (define-instruction bst    "Bit Store from Bit in Register to T Bit in SREG" (b d) "1111 101d dddd 0bbb")
    ;;(define-instruction   call ("Long Call to a Subroutine" (k)   "1001 010k kkkk 111k kkkk kkkk kkkk kkkk")
    (define-instruction cbi    "Clear Bit in I/O Register" (A b) "1001 1000 AAAA Abbb")
    (define-instruction cbr    "Clear Bits in Register" (d K) "0111 KKKK dddd KKKK")
    (define-instruction clc    "Clear Carry Flag" ()    "1001 0100 1000 1000")
    (define-instruction clh    "Clear Half Carry Flag" ()    "1001 0100 1101 1000")
    ;;(define-instruction cli    "Clear Global Interrupt Enable Bit" ()    "1001 0100 1111 1000")
    (define-instruction cln    "Clear Negative Flag" ()    "1001 0100 1010 1000")
    (define-instruction cls    "Clear Sign Flag" ()    "1001 0100 1100 1000")
    (define-instruction clt    "Clear T Bit" ()    "1001 0100 1110 1000")
    (define-instruction clv    "Clear Overflow Flag" ()    "1001 0100 1011 1000")
    (define-instruction clz    "Clear Zero Flag" ()    "1001 0100 1001 1000")
    (define-instruction com    "One’s Complement" (d)   "1001 010d dddd 0000")
    (define-instruction cp     "Compare" (d r) "0001 01rd dddd rrrr")
    (define-instruction cpc    "Compare with Carry" (d r) "0000 01rd dddd rrrr")
    (define-instruction cpi    "Compare with Immediate" (d K) "0011 KKKK dddd KKKK")
    (define-instruction cpse   "Compare Skip if Equal" (d r) "0001 00rd dddd rrrr")
    (define-instruction dec    "Decrement" (d)   "1001 010d dddd 1010")
    (define-instruction des    "Data Encryption Standard" (K)   "1001 0100 KKKK 1011")
    (define-instruction eicall "Extended Indirect Call to Subroutine" ()    "1001 0101 0001 1001")
    (define-instruction eijmp  "Extended Indirect Jump" ()    "1001 0100 0001 1001")
    (define-instruction elpm   "Extended Load Program Memory" (d)   "1001 000d dddd 0110")
    ;;(define-instruction    eor "Exclusive OR" (d r) "0010 01rd dddd rrrr")
    (define-instruction fmul   "Fractional Multiply Unsigned" (d r) "0000 0011 0ddd 1rrr")
    (define-instruction fmuls  "Fractional Multiply Signed" (d r) "0000 0011 1ddd 0rrr")
    (define-instruction fmulsu "Fractional Multiply Signed with Unsigned" (d r) "0000 0011 1ddd 1rrr")
    (define-instruction icall  "Indirect Call to Subroutine" ()    "1001 0101 0000 1001")
    (define-instruction ijmp   "Indirect Jump" ()    "1001 0100 0000 1001")
    ;;(define-instruction     in "Load an I/O Location to Register" (A d) "1011 0AAd dddd AAAA")
    ;;(define-instruction inc    "Increment" (d)   "1001 010d dddd 0011")
    (define-instruction lac    "Load and Clear" (r)   "1001 001r rrrr 0110")
    (define-instruction las    "Load and Set" (r)   "1001 001r rrrr 0101")
    (define-instruction lat    "Load and Toggle" (r)   "1001 001r rrrr 0111")
    ;;(define-instruction    jmp "Jump" (k)   "1001 010k kkkk 110k kkkk kkkk kkkk kkkk")
    (define-instruction ldX    "Load Indirect from Data Space to Register using X" (d)   "1001 000d dddd 1100")
    (define-instruction ldX+   "Load Indirect from Data Space to Register using X, post inc" (d)   "1001 000d dddd 1101")
    (define-instruction ldX-   "Load Indirect from Data Space to Register using X, pre dec" (d)   "1001 000d dddd 1110")
    (define-instruction ldY    "Load Indirect from Data Space to Register using Y" (d)   "1000 000d dddd 1000")
    (define-instruction ldY+   "Load Indirect from Data Space to Register using Y, post inc" (d)   "1001 000d dddd 1001")
    (define-instruction ldY-   "Load Indirect from Data Space to Register using Y, pre dec" (d)   "1001 000d dddd 1010")
    (define-instruction ldY+q  "Load Indirect from Data Space to Register using Y+q" (d q) "10q0 qq0d dddd 1qqq")
    ;;(define-instruction ldZ    "Load Indirect From Data Space to Register using Z" (d)   "1000 000d dddd 0000")
    (define-instruction ldZ+   "Load Indirect From Data Space to Register using Z, post inc" (d)   "1001 000d dddd 0001")
    ;;(define-instruction ldZ-   "Load Indirect From Data Space to Register using Z, pre dec" (d)   "1001 000d dddd 0010")
    (define-instruction ldZ+q  "Load Indirect From Data Space to Register using Z+q" (d q) "10q0 qq0d dddd 0qqq")
    ;;(define-instruction    ldi "Load Immediate" (d K) "1110 KKKK dddd KKKK")
    ;;(define-instruction lds    "Load Direct from Data Space" (d k) "1001 000d dddd 0000 kkkk kkkk kkkk kkkk")
    (define-instruction lds7   "Load Direct from Data Space" (d k) "1010 0kkk dddd kkkk")
    (define-instruction lpm    "Load Program Memory" (d)   "1001 000d dddd 0100")
    (define-instruction lsl    "Logical Shift Left" (d)   "0000 11dd dddd dddd")
    (define-instruction lsr    "Logical Shift Right" (d)   "1001 010d dddd 0110")
    ;;(define-instruction mov    "Copy Register" (d r) "0010 11rd dddd rrrr")
    ;;(define-instruction movw   "Copy Register Word" (d r) "0000 0001 dddd rrrr")
    (define-instruction mul    "Multiply Unsigned" (d r) "1001 11rd dddd rrrr")
    (define-instruction muls   "Multiply Signed" (d r) "0000 0010 dddd rrrr")
    (define-instruction mulsu  "Multiply Signed with Unsigned" (d r) "0000 0011 0ddd 0rrr")
    (define-instruction neg    "Two’s Complement" (d)   "1001 010d dddd 0001")
    ;;(define-instruction nop    "No Operation" ()    "0000 0000 0000 0000")
    ;; (define-instruction or     "Logical OR" (d r) "0010 10rd dddd rrrr")
    (define-instruction ori    "Logical OR with Immediate" (d K) "0110 KKKK dddd KKKK")
    ;;(define-instruction    out "Store Register to I/O Location" (A r) "1011 1AAr rrrr AAAA")
    ;;(define-instruction pop    "Pop Register from Stack" (d)   "1001 000d dddd 1111")
    ;;(define-instruction   push "Push Register on Stack" (d)   "1001 001d dddd 1111")
    ;;(define-instruction rcall  "Relative Call to Subroutine" (k)   "1101 kkkk kkkk kkkk")
    ;;(define-instruction ret    "Return from Subroutine" ()    "1001 0101 0000 1000")
    (define-instruction reti   "Return from Interrupt" ()    "1001 0101 0001 1000")
    ;;(define-instruction rjmp   "Relative Jump" (k)   "1100 kkkk kkkk kkkk")
    (define-instruction rol    "Rotate Left trough Carry" (d)   "0001 11dd dddd dddd")
    (define-instruction ror    "Rotate Right through Carry" (d)   "1001 010d dddd 0111")
    (define-instruction sbc    "Subtract with Carry" (d r) "0000 10rd dddd rrrr")
    (define-instruction sbci   "Subtract Immediate with Carry SBI - Set Bit in I/O Register" (d K) "0100 KKKK dddd KKKK")
    (define-instruction sbi    "Set Bit in I/O Register" (A b) "1001 1010 AAAA Abbb")
    (define-instruction sbic   "Skip if Bit in I/O Register is Cleared" (A b) "1001 1001 AAAA Abbb")
    (define-instruction sbis   "Skip if Bit in I/O Register is Set" (A b) "1001 1011 AAAA Abbb")
    (define-instruction sbiw   "Subtract Immediate from Word" (d K) "1001 0111 KKdd KKKK")
    (define-instruction sbr    "Set Bits in Register" (d K) "0110 KKKK dddd KKKK")
    (define-instruction sbrc   "Skip if Bit in Register is Cleared" (b r) "1111 110r rrrr 0bbb")
    ;;(define-instruction sbrs   "Skip if Bit in Register is Set" (b r) "1111 111r rrrr 0bbb")
    (define-instruction sec    "Set Carry Flag" ()    "1001 0100 0000 1000")
    (define-instruction seh    "Set Half Carry Flag" ()    "1001 0100 0101 1000")
    (define-instruction sei    "Set Global Interrupt Enable Bit" ()    "1001 0100 0111 1000")
    (define-instruction sen    "Set Negative Flag" ()    "1001 0100 0010 1000")
    ;;(define-instruction    ser "Set all Bits in Register" (d)   "1110 1111 dddd 1111")
    (define-instruction ses    "Set Sign Flag" ()    "1001 0100 0100 1000")
    (define-instruction set    "Set T Bit" ()    "1001 0100 0110 1000")
    (define-instruction sev    "Set Overflow Flag" ()    "1001 0100 0011 1000")
    (define-instruction sez    "Set Zero Flag" ()    "1001 0100 0001 1000")
    (define-instruction sleep  "Sleep" ()    "1001 0101 1110 1000")
    ;;(define-instruction spm    "Store Program Memory" ()    "1001 0101 1110 1000")
    (define-instruction stX    "Store Indirect From Register to Data Space using Index X" (r)   "1001 001r rrrr 1100")
    (define-instruction stX+   "Store Indirect From Register to Data Space using Index X, post inc" (r)   "1001 001r rrrr 1110")
    (define-instruction stX-   "Store Indirect From Register to Data Space using Index X, pre dec" (r)   "1001 001r rrrr 1101")
    (define-instruction stY    "Store Indirect From Register to Data Space using Index Y" (r)   "1000 001r rrrr 1000")
    (define-instruction stY+   "Store Indirect From Register to Data Space using Index Y, post inc" (r)   "1001 001r rrrr 1001")
    (define-instruction stY-   "Store Indirect From Register to Data Space using Index Y, pre dec" (r)   "1001 001r rrrr 1010")
    (define-instruction stY+q  "Store Indirect From Register to Data Space using Index Y+q" (q r) "10q0 qq1r rrrr 1qqq")
    ;;(define-instruction stZ    "Store Indirect From Register to Data Space using Index Z" (r)   "1000 001r rrrr 0000")
    (define-instruction stZ+   "Store Indirect From Register to Data Space using Index Z, post inc" (r)   "1001 001r rrrr 0001")
    (define-instruction stZ-   "Store Indirect From Register to Data Space using Index Z, pre dec" (r)   "1001 001r rrrr 0010")
    ;;(define-instruction  stZ+q "Store Indirect From Register to Data Space using Index Z+q" (q r) "10q0 qq1r rrrr 0qqq")
    ;;(define-instruction sts    "Store Direct to Data Space" (d k) "1001 001d dddd 0000 kkkk kkkk kkkk kkkk")
    (define-instruction sts    "Store Direct to Data Space" (d k) "1010 1kkk dddd kkkk")
    (define-instruction sub    "Subtract Without Carry" (d r) "0001 10rd dddd rrrr")
    ;;(define-instruction subi   "Subtract Immediate" (d K) "0101 KKKK dddd KKKK")
    (define-instruction swap   "Swap Nibbles" (d)   "1001 010d dddd 0010")
    (define-instruction tst    "Test for Zero or Minus" (d)   "0010 00dd dddd dddd")
    (define-instruction wdr    "Watchdog Reset" ()    "1001 0101 1010 1000")
    (define-instruction xch    "Exchange" (r)   "1001 001r rrrr 0100")))
